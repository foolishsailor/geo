{"version":3,"sources":["webpack://geo/webpack/universalModuleDefinition","webpack://geo/webpack/bootstrap","webpack://geo/./src/validation.js","webpack://geo/./src/index.js","webpack://geo/./src/prototypes.js","webpack://geo/./src/const.js","webpack://geo/./src/bearings.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","validateBearings","bearings","allowString","results","forEach","bearing","isNaN","push","index","processPointData","positions","returnArray","length","point","Math","abs","lat","lon","parseDMS","err","error","message","validateDMSstring","dmsString","dmsArray","test","position","parseFloat","isFinite","Number","deg","degLL","replace","dms","split","e","splice","slice","NaN","toFixedNumber","geo_const","getAvgOfBearings","getBearingBetweenTwoPoints","getBearingDiff","addHeading","invertHDG","findMiddleAngle","getBoundsOfData","data","reduce","a","latMin","latMax","lngMin","lng","lngMax","Infinity","getDistanceCos","from","to","radius","R","MEAN_RADIUS_IN_M","acos","sin","PI","cos","getDistanceHaversine","dLat","dLon","atan2","sqrt","getDistanceFromSpeedTime","speed","time","distInDegree","HOUR","KM_IN_DEG","distInFeet","KM_TO_FEET","distInKilometers","distInNM","KM_TO_NM","getPostionFromBearingAndDistance","waypoint","distance","dist","brng","lat1","lon1","lat2","asin","lon2","getIntersection","lineA","lineB","XAsum","start","end","XBsum","YAsum","YBsum","lineDenominator","arrs","b","crossTrackDistanceTo","lineStart","lineEnd","currentPoint","haversine","lineLength","this","startToCurrent","startLineBearing","getMinMaxAvgFromArray","newArray","max","min","avg","previous","current","mercator","latitude","longitude","MAX","RADIANS","RADIUS_IN_M","log","tan","humanTime","millisec","seconds","toFixed","minutes","floor","hours","GDP_smoother","source","kink","n_source","n_stack","n_dest","sig","dev_sqr","max_dev_sqr","band_sqr","x12","y12","d12","x13","y13","d13","x23","y23","d23","F","Array","sig_start","sig_end","digits","base","pow","round","toRad","toDeg","toBNG","toDMS","decimal","sec","toLat","toLon","String","NM_TO_KM","NM_IN_DEG","NM_TO_FEET","checkBearings","values","sinValue","cosValue","bearingInRad","bearingInDeg","degrees","radians","startClean","endClean","startLat","endLat","lonDiff","y","x","bearing1","bearing2","baseHdg","addDegrees","hdg","startAngle","endAngle","bearingdiff"],"mappings":"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","file":"geo.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"geo\"] = factory();\n\telse\n\t\troot[\"geo\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","/**\r\n * Inspects array of bearings and returns array of items that are not valid bearing values.\r\n * If all values are valid then returns an array with length 0\r\n * @param {array} bearings\r\n * @param {bool} allowString - bool that determeins is a string that parses to a number is allowed.  Default - false\r\n *\r\n * @return {array} - If there are bad bearings then returns array of objects that containe the index and value\r\n *  @param {number} index - Index of bad item\r\n *  @param {!number} value - Any value that does not parse to a number\r\n */\r\nvalidateBearings = (bearings, allowString) => {\r\n  let results = [];\r\n  bearings.forEach(function (bearing, i) {\r\n    if (isNaN(bearing) || bearing >= 360 || bearing < 0 || bearing === null)\r\n      return results.push({\r\n        index: i,\r\n        value: bearing,\r\n      });\r\n\r\n    if (!allowString && typeof bearing === \"string\")\r\n      results.push({\r\n        index: i,\r\n        value: bearing,\r\n      });\r\n  });\r\n\r\n  return results;\r\n};\r\n\r\n/**\r\n * _processPointData\r\n *\r\n * Checks all items in array for valid formated Position\r\n * @param {Object[]} positions - array of POsition Objects\r\n *  @param {number} positions[].lat\r\n * @param {number} positions[].lon\r\n *\r\n */\r\nprocessPointData = (positions) => {\r\n  try {\r\n    let returnArray = [];\r\n\r\n    for (let i = 0; i < positions.length; i++) {\r\n      const point = positions[i];\r\n\r\n      if (Math.abs(point.lat) > 90) throw \"Latitude out of bounds\";\r\n\r\n      if (Math.abs(point.lon) > 180) throw \"Longitude out of bounds\";\r\n\r\n      point.lat = parseDMS(point.lat);\r\n      point.lon = parseDMS(point.lon);\r\n\r\n      if (isNaN(point.lat) || isNaN(point.lon)) throw \"Malformed Position Data\";\r\n\r\n      returnArray.push(point);\r\n    }\r\n\r\n    return returnArray;\r\n  } catch (err) {\r\n    throw { error: \"GPS Position Error\", message: err };\r\n  }\r\n};\r\n\r\n/**\r\n * testPositionStringRanges\r\n *\r\n * Checks parsed DMS array for any element out of bounds.  Uses regex\r\n * on original string to look for NS to see if item is Lat or Lon\r\n *\r\n * @param {string} dmsString - Original string position\r\n * @param {array} dmsArray - Array of parsed string into elements [Degrees, Minutes, Seconds]\r\n *  @return {null | Error } returns error if item out of bounds or malformed\r\n */\r\nvalidateDMSstring = (dmsString, dmsArray) => {\r\n  //check deg boundaries\r\n  if (Math.abs(dmsArray[0]) > 180) throw \"Position out of bounds\";\r\n\r\n  if (/[NS]/i.test(dmsString) && Math.abs(dmsArray[0]) > 90)\r\n    throw \"Latitude out of bounds\";\r\n\r\n  switch (\r\n    dmsArray.length // convert to decimal degrees...\r\n  ) {\r\n    case 3: // interpret 3-part result as d/m/s\r\n      if (dmsArray[1] > 60 || dmsArray[2] > 60)\r\n        throw \"DMS minutes out of bounds\";\r\n\r\n    case 2: // interpret 2-part result as d/m\r\n      if (dmsArray[1] > 60) throw \"DMS seconds out of bounds\";\r\n\r\n    default:\r\n      return;\r\n  }\r\n};\r\n\r\n/**parseDMS\r\n * Adapted from Chris Veness\r\n * http://www.movable-type.co.uk/scripts/latlong.htmlarses\r\n *\r\n * Parses human readable DMS string into Decimal format\r\n */\r\n\r\nconst parseDMS = (position) => {\r\n  if (!isNaN(parseFloat(position)) && isFinite(position))\r\n    return Number(position);\r\n\r\n  let deg;\r\n  let degLL = position.replace(/^-/, \"\").replace(/[NSEW]/i, \"\"); // strip off any sign or compass dir'n\r\n  let dms = degLL.split(/[^0-9.,]+/); // split out separate d/m/s\r\n\r\n  try {\r\n    //If find '' anywhere but at end of array then malformed data exists so throw error\r\n    dms.forEach((e, i) => {\r\n      if (e == \"\") {\r\n        if (i < dms.length - 1) {\r\n          throw \"Malformed Position Data\";\r\n        }\r\n        dms.splice(i, 1);\r\n      }\r\n    });\r\n\r\n    validateDMSstring(position, dms);\r\n\r\n    switch (\r\n      dms.length // convert to decimal degrees...\r\n    ) {\r\n      case 3: // interpret 3-part result as d/m/s\r\n        deg = dms[0] / 1 + dms[1] / 60 + dms[2] / 3600;\r\n        break;\r\n      case 2: // interpret 2-part result as d/m\r\n        deg = dms[0] / 1 + dms[1] / 60;\r\n        break;\r\n      case 1: // decimal or non-separated dddmmss\r\n        if (/[NS]/i.test(position)) degLL = \"0\" + degLL; // - normalise N/S to 3-digit degrees\r\n        deg =\r\n          dms[0].slice(0, 3) / 1 +\r\n          dms[0].slice(3, 5) / 60 +\r\n          dms[0].slice(5) / 3600;\r\n        break;\r\n      default:\r\n        return NaN;\r\n    }\r\n  } catch (err) {\r\n    return NaN;\r\n  }\r\n\r\n  if (/^-/.test(position) || /[WS]/i.test(position)) deg = -deg; // take '-', west and south as -ve\r\n  return deg.toFixedNumber(7);\r\n};\r\n\r\nmodule.exports = {\r\n  validateBearings,\r\n  processPointData,\r\n  validateDMSstring,\r\n  parseDMS,\r\n};\r\n","require(\"./prototypes\");\n\nconst { geo_const } = require(\"./const\");\nconst { parseDMS } = require(\"./validation\");\nconst { bearings } = require(\"./bearings\");\n\nmodule.exports = (() => {\n  /**\n   * getBoundsOfData\n   *\n   * Takes an array of geoJSON objects and returns a boundary box containeing those values\n   * @param {array} data array of geoJSON object\n   * @param {object} geoJSON\n   * @property {number} lat\n   * @property {number} lon\n   *\n   * @returns {object} Return object has four cornes of bounds of data set\n   * @property {latMin} latMin\n   * @property {latMax} latMax\n   * @property {lonMin}\n   * @property {lonMax}\n   */\n  const getBoundsOfData = (data) => {\n    const boundsObject = data.reduce(\n      function (a, c) {\n        return {\n          latMin: isNaN(a.latMin) || a.latMin > c.lat ? c.lat : a.latMin,\n          latMax: isNaN(a.latMax) || a.latMax < c.lat ? c.lat : a.latMax,\n          lngMin: isNaN(a.lngMin) || a.lngMin > c.lng ? c.lng : a.lngMin,\n          lngMax: isNaN(a.lngMax) || a.lngMax < c.lng ? c.lng : a.lngMax,\n        };\n      },\n      {\n        latMin: Infinity,\n        latMax: -Infinity,\n        lngMin: Infinity,\n        lngMax: -Infinity,\n      }\n    );\n  };\n\n  /*-------------------------------------------------------\n\n    DISTANCE FUNCTIONS\n\n  --------------------------------------------------------*/\n\n  /**\n    getDistanceCos\n\n    Calculate distance between two points in km.  This method generates more accurate distance for points close together\n    like within a tunr or on a race course\n\n    @param {object} from - GPS position\n      @property {number} lat\n      @property {number} lon\n    @param {object} to - GPS position\n      @property {number} lat\n      @property {number} lon\n    @return {Number} - km [default]\n\n  */\n  const getDistanceCos = (from, to, radius) => {\n    let R = radius || geo_const.MEAN_RADIUS_IN_M / 1000; //default to earth radius in km\n\n    let d =\n      Math.acos(\n        Math.sin((from.lat * Math.PI) / 180) *\n          Math.sin((to.lat * Math.PI) / 180) +\n          Math.cos((from.lat * Math.PI) / 180) *\n            Math.cos((to.lat * Math.PI) / 180) *\n            Math.cos(((to.lon - from.lon) * Math.PI) / 180)\n      ) * R;\n    return d;\n  };\n\n  /**\n    getDistanceHaversine\n\n    Calculate distance between two points.  This method generates more accurate distance for points farther apart\n    and incorporates the curve of the earth as part of the equation\n\n    @param {object} from - GPS position\n      @property {number} lat\n      @property {number} lon\n    @param {object} to - GPS position\n      @property {number} lat\n      @property {number} lon\n    @return {Number}\n\n  */\n  const getDistanceHaversine = (from, to) => {\n    let R = geo_const.MEAN_RADIUS_IN_M / 1000; // earth's mean radius in km\n    let dLat = ((to.lat - from.lat) * Math.PI) / 180;\n    let dLon = ((to.lon - from.lon) * Math.PI) / 180;\n    from.lat = (from.lat * Math.PI) / 180;\n    to.lat = (to.lat * Math.PI) / 180;\n\n    let a =\n      Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n      Math.cos(from.lat) *\n        Math.cos(to.lat) *\n        Math.sin(dLon / 2) *\n        Math.sin(dLon / 2);\n    let c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    let d = R * c;\n    return d;\n  };\n\n  /**\n   * getDistanceFromSpeedTime\n   *\n   * Calculate distance from speed (in kM/hour) and Time (seconds)\n   *\n   * @param {number} speed - speed in kM/hr\n   * @param {number} time - time in Seconds\n   * @return {object}\n   *      @property {number} distInDegree\n   *      @property {number} distInFeet\n   *      @property {number} distInKilometers\n   *\n   * */\n\n  const getDistanceFromSpeedTime = (speed, time) => {\n    return {\n      distInDegree: (speed * (time / geo_const.HOUR)) / geo_const.KM_IN_DEG,\n      distInFeet: speed * (time / geo_const.HOUR) * geo_const.KM_TO_FEET,\n      distInKilometers: speed * (time / geo_const.HOUR),\n      distInNM: speed * (time / geo_const.HOUR) * geo_const.KM_TO_NM,\n    };\n  };\n\n  /**\n    getPostionFromBearingAndDistance\n\n    Calculate lat and lon point from existing point, bearing and distance.  Inputs in KM\n\n    @param {object} arrs -\n      @property {object} waypoint\n      @property {number} distance in km\n      @property {number} bearing\n\n    @return {object}\n      @property {number} lat - lat derived\n      @property {number} lng - lon derived\n\n  */\n\n  const getPostionFromBearingAndDistance = (waypoint, distance, bearing) => {\n    let position = {\n      lat: waypoint.lat(),\n      lng: waypoint.lng(),\n    };\n\n    dist = distance / geo_const.MEAN_RADIUS_IN_M / 1000;\n\n    let brng = (Number(bearing) * Math.PI) / 180;\n    let lat1 = position.lat;\n    lat1 = (lat1 * Math.PI) / 180;\n    let lon1 = position.lng;\n    lon1 = (lon1 * Math.PI) / 180;\n\n    let lat2 = Math.asin(\n      Math.sin(lat1) * Math.cos(dist) +\n        Math.cos(lat1) * Math.sin(dist) * Math.cos(brng)\n    );\n\n    let lon2 =\n      lon1 +\n      Math.atan2(\n        Math.sin(brng) * Math.sin(dist) * Math.cos(lat1),\n        Math.cos(dist) - Math.sin(lat1) * Math.sin(lat2)\n      );\n\n    return {\n      lat: (lat2 * 180) / Math.PI,\n      lng: (lon2 * 180) / Math.PI,\n    };\n  };\n\n  /**\n    getIntersection\n\n    Calculate intersection point between two lines/routes in lat and lon.  They are not required to overlap to calulate\n\n   \n      @property {object} lineA\n        @property {number} lat\n        @property {number} lon\n\n      @property {object} lineB\n        @property {number} lat\n        @property {number} lon\n\n\n    @return {object}\n      @property {number} lat\n      @property {number} lon\n\n  */\n  const getIntersection = ({ lineA, lineB }) => {\n    let XAsum = lineA.start.lon - lineA.end.lon;\n    let XBsum = lineB.start.lon - lineB.end.lon;\n    let YAsum = lineA.start.lat - lineA.end.lat;\n    let YBsum = lineB.start.lat - lineB.end.lat;\n\n    let lineDenominator = XAsum * YBsum - YAsum * XBsum;\n    if (lineDenominator == 0.0) return false;\n\n    let a =\n      lineA.start.lon * lineA.end.lat - arrs.lineA.start.lat * lineA.end.lon;\n    let b = lineB.start.lon * lineB.end.lat - lineB.start.lat * lineB.end.lon;\n\n    let lat = (a * YBsum - b * YAsum) / lineDenominator;\n    let lon = (a * XBsum - b * XAsum) / lineDenominator;\n\n    return { lat, lon };\n  };\n\n  /**\n   * Returns (signed) distance from ‘this’ point to great circle defined by start-point and end-point.\n   *\n   * @param   {object} lineStart - Start point of great circle path.\n       @param {number} lat\n       @param {number} lon\n   * @param   {object} lineEnd - End point of great circle path.\n       @param {number} lat\n       @param {number} lon\n     @param   {object} currentPoint -current location\n         @param {number} lat\n         @param {number} lon\n   * @param   {bool} haversine - use haversine versus cosine calculation.  Cos is best for smalelr distances \n   * @returns {number} Distance to great circle (-ve if to left, +ve if to right of path).\n   *    *    \n   */\n  function crossTrackDistanceTo({\n    lineStart,\n    lineEnd,\n    currentPoint,\n    haversine = false,\n  }) {\n    let lineLength = haversine\n      ? this.getDistanceHaversine(\n          lineStart,\n          currentPoint,\n          geo_const.MEAN_RADIUS_IN_M\n        ) / geo_const.MEAN_RADIUS_IN_M\n      : this.getDistanceCos(\n          lineStart,\n          currentPoint,\n          geo_const.MEAN_RADIUS_IN_M\n        ) / geo_const.MEAN_RADIUS_IN_M;\n\n    let startToCurrent =\n      this.getBearingBetweenTwoPoints(lineStart, currentPoint) *\n      (Math.PI / 180);\n\n    let startLineBearing =\n      this.getBearingBetweenTwoPoints(lineStart, lineEnd) * (Math.PI / 180);\n\n    let XTE = Math.asin(\n      Math.sin(lineLength) * Math.sin(startToCurrent - startLineBearing)\n    );\n\n    return XTE * geo_const.MEAN_RADIUS_IN_M;\n  }\n\n  /*------------------------------------------\n\n        AVERAGING and AGGREGATING FUNCTIONS\n\n    -------------------------------------------*/\n\n  /**\n      Get min, max, avg of a given property from array and filters out non numbers or bad data\n\n      @param {object} arrs\n        @property {array} array - Array of racedata objects to get min,max, avg from\n        @property {object} dataSource - propery of racedata object to use as basis for reducing array\n\n      @returns {object}\n        @property {number} max\n        @property {number} min\n        @property {number} avg\n\n    */\n  const getMinMaxAvgFromArray = (newArray) => {\n    //strips out bad data\n    let max = newArray.reduce(function (a, b) {\n      if (isNaN(a) || a === null || a === \"\") a = -Infinity;\n      if (isNaN(b) || b === null || b === \"\") b = -Infinity;\n      return Math.max(a, b);\n    }, -Infinity);\n\n    let min = newArray.reduce(function (a, b) {\n      if (isNaN(a) || a === null || a === \"\") a = Infinity;\n      if (isNaN(b) || b === null || b === \"\") b = Infinity;\n      return Math.min(a, b);\n    }, Infinity);\n\n    let avg =\n      newArray.reduce(function (previous, current) {\n        if (isNaN(current) || current === null || current === \"\")\n          return previous;\n        return previous + Number(current);\n      }, 0) / newArray.length;\n\n    return { min, max, avg };\n  };\n\n  /**\n   * Convert lat/lon to mercator projection points\n   */\n  const mercator = ({ latitude, longitude }) => {\n    const MAX = 85.0511287798;\n    const RADIANS = Math.PI / 180;\n    let point = {};\n\n    point.lon = geo_const.RADIUS_IN_M * longitude * RADIANS;\n    point.lat = Math.max(Math.min(MAX, latitude), -MAX) * RADIANS;\n    point.lat =\n      geo_const.RADIUS_IN_M * Math.log(Math.tan(Math.PI / 4 + point.lat / 2));\n\n    return point;\n  };\n\n  /*-----------------------------------------------\n\n    TIME FUNCTIONS\n\n---------------------------------------------------*/\n\n  /**\n   * humanTime\n   *\n   * Produce human readable time from milliseconds.  Automatically hide/add mins secs days etc\n   *\n   */\n  const humanTime = (millisec) => {\n    let seconds = (millisec / 1000).toFixed(0);\n    let minutes = Math.floor(seconds / 60);\n    let hours = \"\";\n    if (minutes > 59) {\n      hours = Math.floor(minutes / 60);\n      hours = hours >= 10 ? hours : \"0\" + hours;\n      minutes = minutes - hours * 60;\n      minutes = minutes >= 10 ? minutes : \"0\" + minutes;\n    }\n\n    seconds = Math.floor(seconds % 60);\n    seconds = seconds >= 10 ? seconds : \"0\" + seconds;\n    if (hours != \"\") {\n      return hours + \":\" + minutes + \":\" + seconds;\n    }\n    return minutes + \":\" + seconds;\n  };\n\n  /*-----------------------------------------------------------------\n\n    LINE OR COURSE SMOOTHING ALGORYTHMS\n\n  ------------------------------------------------------------------*/\n  /**\n  GDouglasPeucker\n  Stack-based Douglas Peucker line simplification routine\n   returned is a reduced google.maps.LatLng array\n   After code by  Dr. Gary J. Robinson,\n   Environmental Systems Science Centre,\n   University of Reading, Reading, UK\n\n   @param {array} source Input coordinates\n   @param {number} kink in metres, kinks above this depth kept.  Kink depth is the height of the triangle abc where a-b and b-c are two consecutive line segments\n\n*/\n\n  function GDP_smoother(source, kink) {\n    let n_source, n_stack, n_dest, start, end, i, sig;\n    let dev_sqr, max_dev_sqr, band_sqr;\n    let x12, y12, d12, x13, y13, d13, x23, y23, d23;\n    let F = (Math.PI / 180.0) * 0.5;\n    let index = new Array(); /* aray of indexes of source points to include in the reduced line */\n    let sig_start = new Array(); /* indices of start & end of working section */\n    let sig_end = new Array();\n\n    /* check for simple cases */\n\n    if (source.length < 3) return source; /* one or two points */\n\n    /* more complex case. initialize stack */\n\n    n_source = source.length;\n    band_sqr =\n      (kink * 360.0) / (2.0 * Math.PI * 6378137.0); /* Now in degrees */\n    band_sqr *= band_sqr;\n    n_dest = 0;\n    sig_start[0] = 0;\n    sig_end[0] = n_source - 1;\n    n_stack = 1;\n\n    /* while the stack is not empty  ... */\n    while (n_stack > 0) {\n      /* ... pop the top-most entries off the stacks */\n\n      start = sig_start[n_stack - 1];\n      end = sig_end[n_stack - 1];\n      n_stack--;\n\n      if (end - start > 1) {\n        /* any intermediate points ? */\n\n        /* ... yes, so find most deviant intermediate point to\n                       either side of line joining start & end points */\n\n        x12 = source[end].lon - source[start].lon;\n        y12 = source[end].lat - source[start].lat;\n        if (Math.abs(x12) > 180.0) x12 = 360.0 - Math.abs(x12);\n        x12 *= Math.cos(\n          F * (source[end].lat + source[start].lat)\n        ); /* use avg lat to reduce lon */\n        d12 = x12 * x12 + y12 * y12;\n\n        for (i = start + 1, sig = start, max_dev_sqr = -1.0; i < end; i++) {\n          x13 = source[i].lon - source[start].lon;\n          y13 = source[i].lat - source[start].lat;\n          if (Math.abs(x13) > 180.0) x13 = 360.0 - Math.abs(x13);\n          x13 *= Math.cos(F * (source[i].lat + source[start].lat));\n          d13 = x13 * x13 + y13 * y13;\n\n          x23 = source[i].lon - source[end].lon;\n          y23 = source[i].lat - source[end].lat;\n          if (Math.abs(x23) > 180.0) x23 = 360.0 - Math.abs(x23);\n          x23 *= Math.cos(F * (source[i].lat + source[end].lat));\n          d23 = x23 * x23 + y23 * y23;\n\n          if (d13 >= d12 + d23) dev_sqr = d23;\n          else if (d23 >= d12 + d13) dev_sqr = d13;\n          else\n            dev_sqr = ((x13 * y12 - y13 * x12) * (x13 * y12 - y13 * x12)) / d12; // solve triangle\n\n          if (dev_sqr > max_dev_sqr) {\n            sig = i;\n            max_dev_sqr = dev_sqr;\n          }\n        }\n\n        if (max_dev_sqr < band_sqr) {\n          /* is there a sig. intermediate point ? */\n          /* ... no, so transfer current start point */\n          index[n_dest] = start;\n          n_dest++;\n        } else {\n          /* ... yes, so push two sub-sections on stack for further processing */\n          n_stack++;\n          sig_start[n_stack - 1] = sig;\n          sig_end[n_stack - 1] = end;\n          n_stack++;\n          sig_start[n_stack - 1] = start;\n          sig_end[n_stack - 1] = sig;\n        }\n      } else {\n        /* ... no intermediate points, so transfer current start point */\n        index[n_dest] = start;\n        n_dest++;\n      }\n    }\n\n    /* transfer last point */\n    index[n_dest] = n_source - 1;\n    n_dest++;\n\n    /* make return array */\n    let r = new Array();\n    for (let i = 0; i < n_dest; i++) r.push(source[index[i]]);\n\n    return r;\n  }\n\n  return {\n    getAvgOfBearings: bearings.getAvgOfBearings,\n    getBearingBetweenTwoPoints: bearings.getBearingBetweenTwoPoints,\n    getBearingDiff: bearings.getBearingDiff,\n    addHeading: bearings.addHeading,\n    invertHDG: bearings.invertHDG,\n    findMiddleAngle: bearings.findMiddleAngle,\n    parseDMS: bearings.parseDMS,\n    getBoundsOfData,\n    getDistanceCos,\n    getDistanceHaversine,\n    getDistanceFromSpeedTime,\n    getPostionFromBearingAndDistance,\n    getIntersection,\n    crossTrackDistanceTo,\n    getMinMaxAvgFromArray,\n    mercator,\n    humanTime,\n    GDP_smoother,\n  };\n})();\n","const { parseDMS } = require(\"./validation\");\r\n\r\nNumber.prototype.toFixedNumber = function (digits, base) {\r\n  var pow = Math.pow(base || 10, digits);\r\n  return Math.round(this * pow) / pow;\r\n};\r\n\r\n// convert degrees to radians\r\nNumber.prototype.toRad = function () {\r\n  return (this * Math.PI) / 180;\r\n};\r\n\r\n// convert radians to degrees (signed)\r\nNumber.prototype.toDeg = function () {\r\n  return (this * 180) / Math.PI;\r\n};\r\n\r\n// convert radians to degrees (as bearing: 0...359)\r\nNumber.prototype.toBNG = function () {\r\n  return (this.toDeg() + 360) % 360;\r\n};\r\n\r\n// convert numeric degrees to human readable deg/min/sec - i.e. 41.34445 = 041°20'40\"\r\nNumber.prototype.toDMS = function () {\r\n  let decimal = Math.abs(this);\r\n  decimal += 1 / 7200; // add to second for rounding\r\n  let deg = Math.floor(decimal);\r\n  let min = Math.floor((decimal - deg) * 60);\r\n  let sec = Number(((decimal - deg - min / 60) * 3600).toFixed(2));\r\n\r\n  // add leading zeros if required\r\n  if (deg < 100) deg = \"0\" + deg;\r\n  if (deg < 10) deg = \"0\" + deg;\r\n  if (min < 10) min = \"0\" + min;\r\n  if (sec < 10) sec = \"0\" + sec;\r\n  return `${deg}\\u00B0${min}\\u0027${sec}\\u0022`;\r\n};\r\n\r\nNumber.prototype.toLat = function () {\r\n  // convert numeric degrees to deg/min/sec latitude\r\n  return this.toDMS().slice(1) + (this < 0 ? \"S\" : \"N\"); // knock off initial '0' for lat\r\n};\r\n\r\nNumber.prototype.toLon = function () {\r\n  // convert numeric degrees to deg/min/sec longitude\r\n  return this.toDMS() + (this > 0 ? \"E\" : \"W\");\r\n};\r\n\r\n/**\r\n * Parses human readable DMS string into Decimal format\r\n *\r\n * See: /validation/parseDMS for attribution nad info *\r\n */\r\n\r\nString.prototype.parseDMS = function () {\r\n  return parseDMS(this);\r\n};\r\n","const geo_const = {\r\n  KM_TO_NM: 0.539957,\r\n  NM_TO_KM: 1.852,\r\n  HOUR: 3600,\r\n  KM_IN_DEG: 111.12,\r\n  NM_IN_DEG: 60,\r\n  NM_TO_FEET: 6076,\r\n  KM_TO_FEET: 3280.84,\r\n  RADIUS_IN_M: 6378137, //radius earth at equator\r\n  MEAN_RADIUS_IN_M: 6371000, //earth mean radius\r\n};\r\n\r\nmodule.exports = { geo_const };\r\n","const { validateBearings, processPointData } = require(\"./validation\");\r\n\r\nmodule.exports = {\r\n  /*------------------------------------------\r\n\r\n        COMPASS HEADING AND ANGLE FUNCTIONS\r\n\r\n    -------------------------------------------*/\r\n  /**\r\n   * getAvgOfBearings\r\n   *\r\n   * Return average of all elements in array normalized for compass bearings.\r\n   * Numbers must be converted to radians and then compared\r\n   *\r\n   * @param {array} bearings - array of bearing values\r\n   * @returns {object}\r\n   * @param {number} degrees - the average of bearings in degrees\r\n   * @param {number} radians - the average of bearings in radians -\r\n   *\r\n   * Legitimate values are between 0 and 360 - not inclusive of 360, i.e. 359.99999\r\n   */\r\n  getAvgOfBearings: (bearings) => {\r\n    try {\r\n      if (bearings.length < 2) throw \"Less than two bearings\";\r\n\r\n      //check for malformed data\r\n      let checkBearings = validateBearings(bearings);\r\n      if (checkBearings.length > 0) throw checkBearings;\r\n\r\n      let values = bearings.reduce(\r\n        function (a, c) {\r\n          return {\r\n            sinValue: (a.sinValue += Math.sin(c.toRad())),\r\n            cosValue: (a.cosValue += Math.cos(c.toRad())),\r\n          };\r\n        },\r\n        { sinValue: 0, cosValue: 0 }\r\n      );\r\n\r\n      let bearingInRad = Math.atan2(values.sinValue, values.cosValue);\r\n      let bearingInDeg = bearingInRad.toDeg();\r\n\r\n      if (bearingInDeg <= -1) bearingInDeg += 359;\r\n\r\n      return {\r\n        degrees: Math.abs(Math.round(bearingInDeg * 100) / 100),\r\n        radians: bearingInRad,\r\n      };\r\n    } catch (err) {\r\n      return { error: \"Invalid Bearings\", message: err };\r\n    }\r\n  },\r\n\r\n  /**\r\n    getBearingBetweenTwoPoints\r\n\r\n    Calculate bearing between two positions\r\n\r\n    @param {object} start - GPS position\r\n      @param {number} start.lat\r\n      @param {number} start.lon\r\n    @param {object} end - GPS position\r\n      @param {number} end.lat\r\n      @param {number} end.lon\r\n    @param {number} decimal - number decimal places, default 0\r\n    @return {Number | Error} \r\n\r\n  */\r\n  getBearingBetweenTwoPoints: (start, end, decimal = 0) => {\r\n    try {\r\n      const [startClean, endClean] = processPointData([start, end]);\r\n\r\n      let startLat = startClean.lat.toRad();\r\n      let endLat = endClean.lat.toRad();\r\n      let lonDiff = (endClean.lon - startClean.lon).toRad();\r\n\r\n      let y = Math.sin(lonDiff) * Math.cos(endLat);\r\n      let x =\r\n        Math.cos(startLat) * Math.sin(endLat) -\r\n        Math.sin(startLat) * Math.cos(endLat) * Math.cos(lonDiff);\r\n\r\n      return ((Math.atan2(y, x).toDeg() + 360) % 360).toFixedNumber(decimal);\r\n    } catch (err) {\r\n      return err;\r\n    }\r\n  },\r\n\r\n  /**\r\n    getBearingDiff\r\n\r\n    Calculate normalized difference between two bearings\r\n\r\n    @param {number} bearing1\r\n    @param {number} bearing2\r\n\r\n    @return {number}\r\n\r\n  */\r\n  getBearingDiff: (bearing1, bearing2) => {\r\n    return Math.min(\r\n      bearing1 - bearing2 < 0 ? bearing1 - bearing2 + 360 : bearing1 - bearing2,\r\n      bearing2 - bearing1 < 0 ? bearing2 - bearing1 + 360 : bearing2 - bearing1\r\n    );\r\n  },\r\n\r\n  /**\r\n    addHeading\r\n\r\n    Adds and normalizes two bearings\r\n\r\n    @param {number} baseHdg\r\n    @param {number} addDegrees\r\n\r\n    @return {number} new bearing\r\n\r\n  */\r\n  addHeading: (baseHdg, addDegrees) => {\r\n    hdg = baseHdg + addDegrees;\r\n    if (hdg < 0) {\r\n      hdg += 360;\r\n    }\r\n    if (hdg >= 360) {\r\n      hdg -= 360;\r\n    }\r\n\r\n    return hdg;\r\n  },\r\n\r\n  /**\r\n    invertHDG\r\n\r\n    Inverts and normalizes heading\r\n\r\n    @param {number} hdg\r\n    @return {number} new bearing\r\n\r\n  */\r\n  invertHDG: (hdg) => {\r\n    hdg += 180; //quadrant orientaion\r\n    if (hdg < 0) {\r\n      hdg += 360;\r\n    }\r\n    if (hdg >= 360) {\r\n      hdg -= 360;\r\n    }\r\n\r\n    return hdg;\r\n  },\r\n\r\n  /**\r\n    findMiddleAngle\r\n\r\n    Calculates difference in two bearings and returns median bearing between those two bearings\r\n    Effectively finds the smaller of the two angles of a cricle and returns the median angle\r\n\r\n    @param {number} startAngle\r\n    @param {number} endAngle\r\n\r\n    @return {number} median bearing\r\n\r\n  */\r\n  findMiddleAngle: (startAngle, endAngle) => {\r\n    startAngle = Math.round(startAngle);\r\n    endAngle = Math.round(endAngle);\r\n\r\n    let bearingdiff = this.getBearingDiff(startAngle, endAngle);\r\n\r\n    if (this.addHeading(startAngle, bearingdiff) == endAngle) {\r\n      return this.addHeading(startAngle, bearingdiff / 2);\r\n    } else {\r\n      return this.addHeading(startAngle, (bearingdiff * -1) / 2);\r\n    }\r\n  },\r\n};\r\n"],"sourceRoot":""}