{"version":3,"sources":["webpack://geo/webpack/universalModuleDefinition","webpack://geo/webpack/bootstrap","webpack://geo/./src/parseDMS/index.js","webpack://geo/./src/prototypes.js","webpack://geo/./src/index.js","webpack://geo/./src/parseDMS/components/processPointObject.js","webpack://geo/./src/parseDMS/components/processDMS.js","webpack://geo/./src/parseDMS/components/validateDMSString.js","webpack://geo/./src/parseDMS/components/processDMSstring.js","webpack://geo/./src/bearings.js","webpack://geo/./src/arrayUtils.js","webpack://geo/./src/distance.js","webpack://geo/./src/position.js","webpack://geo/./src/time.js","webpack://geo/./src/smoothing.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","processPointObject","processDMS","parseDMS","data","options","Array","isArray","flatten","reduce","a","concat","map","item","error","message","Number","toFixedNumber","digits","base","pow","Math","round","this","toRad","PI","toDeg","toBNG","toDMS","decimal","abs","deg","floor","min","sec","toFixed","toLat","slice","toLon","String","getAvgOfBearings","getBearingBetweenTwoPoints","getBearingDiff","addHeading","invertHDG","findMiddleAngle","getBoundsOfData","getMinMaxAvgFromArray","getDistanceCos","getDistanceHaversine","getDistanceFromSpeedTime","crossTrackDistanceTo","getIntersectionPoint","getPostionFromBearingAndDistance","mercator","humanTime","GDP_smoother","isValidGeoObject","point","func","lat","parseFloat","lon","continueOnError","keys","obj","validateDMSstring","processDMSstring","position","test","isNaN","isFinite","dms","replace","split","forEach","e","length","splice","err","dmsString","dmsArray","handleError","validateBearings","bearings","allowString","results","bearing","push","index","checkBearings","values","sinValue","sin","cosValue","cos","bearingInRad","atan2","bearingInDeg","degrees","radians","start","end","startClean","endClean","startLat","endLat","lonDiff","y","x","bearing1","bearing2","baseHdg","addDegrees","hdg","startAngle","endAngle","bearingdiff","newArray","max","b","Infinity","avg","previous","current","latMin","latMax","lngMin","lng","lngMax","from","to","radius","R","geo_const","MEAN_RADIUS_IN_M","acos","dLat","dLon","sqrt","speed","time","distInDegree","HOUR","KM_IN_DEG","distInFeet","KM_TO_FEET","distInKilometers","distInNM","KM_TO_NM","lineStart","lineEnd","currentPoint","haversine","lineLength","startToCurrent","startLineBearing","asin","lineA","lineB","XAsum","XBsum","YAsum","YBsum","lineDenominator","arrs","waypoint","distance","dist","brng","lat1","lon1","lat2","lon2","latitude","longitude","MAX","RADIANS","RADIUS_IN_M","log","tan","millisec","seconds","minutes","hours","source","kink","n_source","n_stack","n_dest","sig","dev_sqr","max_dev_sqr","band_sqr","x12","y12","d12","x13","y13","d13","x23","y23","d23","F","sig_start","sig_end"],"mappings":"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","file":"geo.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"geo\"] = factory();\n\telse\n\t\troot[\"geo\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","/**\r\n * parseDMS\r\n *\r\n * Versitle parsing of human readbale GPS data into decimal format format.  Handles awide\r\n * variety of data entry to allow users flexibility in doing data entry.\r\n *\r\n * It can also handle deeply nested diverse data formats and return the information formated\r\n * into existing structure or flattened.\r\n *\r\n * Options include ability to throw error when malformed data encountered to enable use as a validation\r\n * on forms or to return all malfored data in seperate array to allow parsing of large data sets.\r\n *\r\n * Adapted and built from Chris Veness original script\r\n *  * http://www.movable-type.co.uk/scripts/latlong.htmlarses\r\n *\r\n * FOr more detail see:  https://github.com/foolishsailor/geo\r\n *\r\n */\r\n\r\nconst processPointObject = require(\"./components/processPointObject\");\r\nconst processDMS = require(\"./components/processDMS\");\r\nrequire(\"../prototypes\");\r\n\r\n/**\r\n *  parseDMS - main parsing function\r\n * @param {String | Array | Object} data\r\n *  @param {String | Number} data.lat\r\n *  @param {String | Number} data.lon\r\n *`@param {Object} [options] -    option flags for processing data\r\n *  @param {bool} [strict=true] - Disallow any chars not part of normal DMS\r\n *  @param {bool} [flatten=false] - Keep input strcture or flatten to single array\r\n *  @param {bool} [returnMalformed=false] - Return second array of malformed items and their original indeox\r\n *  @param {bool} [keepError=false] - Keep malformed elements inSitu otherwise shows error.\r\n *  @param {bool} [continueOnError=false] - throw error if malformed data based on strict options settings is found\r\n *                                          if set to true then return error object in istu:  {\"Error\": err title}\r\n *\r\n */\r\n\r\nconst parseDMS = (data, options = {}) => {\r\n  if (data == null) return null;\r\n  //Check if string\r\n  if (typeof data === \"string\" || typeof data === \"number\")\r\n    return processDMS(data, options);\r\n\r\n  //Check if Array and recursively process\r\n  if (Array.isArray(data))\r\n    return options.flatten\r\n      ? data.reduce((a, c) => a.concat(parseDMS(c, options)), [])\r\n      : data.map((item) => parseDMS(item, options));\r\n  //\r\n\r\n  //Check if object with lat lon\r\n  if (typeof data === \"object\") {\r\n    return processPointObject(data, options, parseDMS);\r\n  }\r\n\r\n  throw {\r\n    error: \"Malformed Position Data\",\r\n    message: \"Malformed Data\",\r\n  };\r\n};\r\n\r\nmodule.exports = parseDMS;\r\n","const parseDMS = require(\"./parseDMS\");\r\n\r\nNumber.prototype.toFixedNumber = function (digits, base) {\r\n  var pow = Math.pow(base || 10, digits);\r\n  return Math.round(this * pow) / pow;\r\n};\r\n\r\n// convert degrees to radians\r\nNumber.prototype.toRad = function () {\r\n  return (this * Math.PI) / 180;\r\n};\r\n\r\n// convert radians to degrees (signed)\r\nNumber.prototype.toDeg = function () {\r\n  return (this * 180) / Math.PI;\r\n};\r\n\r\n// convert radians to degrees (as bearing: 0...359)\r\nNumber.prototype.toBNG = function () {\r\n  return (this.toDeg() + 360) % 360;\r\n};\r\n\r\n// convert numeric degrees to human readable deg/min/sec - i.e. 41.34445 = 041°20'40\"\r\nNumber.prototype.toDMS = function () {\r\n  let decimal = Math.abs(this);\r\n  decimal += 1 / 7200; // add to second for rounding\r\n  let deg = Math.floor(decimal);\r\n  let min = Math.floor((decimal - deg) * 60);\r\n  let sec = Number(((decimal - deg - min / 60) * 3600).toFixed(2));\r\n\r\n  // add leading zeros if required\r\n  if (deg < 100) deg = \"0\" + deg;\r\n  if (deg < 10) deg = \"0\" + deg;\r\n  if (min < 10) min = \"0\" + min;\r\n  if (sec < 10) sec = \"0\" + sec;\r\n  return `${deg}\\u00B0${min}\\u0027${sec}\\u0022`;\r\n};\r\n\r\nNumber.prototype.toLat = function () {\r\n  // convert numeric degrees to deg/min/sec latitude\r\n  return this.toDMS().slice(1) + (this < 0 ? \"S\" : \"N\"); // knock off initial '0' for lat\r\n};\r\n\r\nNumber.prototype.toLon = function () {\r\n  // convert numeric degrees to deg/min/sec longitude\r\n  return this.toDMS() + (this > 0 ? \"E\" : \"W\");\r\n};\r\n\r\n/**\r\n * Parses human readable DMS string into Decimal format\r\n *\r\n * See: /validation/parseDMS for attribution nad info *\r\n */\r\n\r\nString.prototype.parseDMS = function () {\r\n  return parseDMS(this);\r\n};\r\n","const parseDMS = require(\"./parseDMS\");\nconst {\n  getAvgOfBearings,\n  getBearingBetweenTwoPoints,\n  getBearingDiff,\n  addHeading,\n  invertHDG,\n  findMiddleAngle,\n} = require(\"./bearings\");\nconst { getBoundsOfData, getMinMaxAvgFromArray } = require(\"./arrayUtils\");\nconst {\n  getDistanceCos,\n  getDistanceHaversine,\n  getDistanceFromSpeedTime,\n  crossTrackDistanceTo,\n} = require(\"./distance\");\nconst {\n  getIntersectionPoint,\n  getPostionFromBearingAndDistance,\n  mercator,\n} = require(\"./position\");\nconst { humanTime } = require(\"./time\");\nconst { GDP_smoother } = require(\"./smoothing\");\n\nmodule.exports = (() => {\n  return {\n    getAvgOfBearings,\n    getBearingBetweenTwoPoints,\n    getBearingDiff,\n    addHeading,\n    invertHDG,\n    findMiddleAngle,\n    parseDMS,\n    getBoundsOfData,\n    getMinMaxAvgFromArray,\n    getDistanceCos,\n    getDistanceHaversine,\n    getDistanceFromSpeedTime,\n    crossTrackDistanceTo,\n    getIntersectionPoint,\n    getPostionFromBearingAndDistance,\n    mercator,\n\n    humanTime,\n    GDP_smoother,\n  };\n})();\n","const isValidGeoObject = (point) => {\r\n  return point.hasOwnProperty(\"lat\") && point.hasOwnProperty(\"lon\")\r\n    ? true\r\n    : false;\r\n};\r\n\r\nconst processPointObject = (data, options, func) => {\r\n  if (isValidGeoObject) {\r\n    const lat =\r\n      Math.abs(parseFloat(data.lat)) > 90\r\n        ? {\r\n            error: \"Latitude out of bounds\",\r\n          }\r\n        : func(data.lat, options);\r\n    const lon =\r\n      Math.abs(parseFloat(data.lon)) > 180\r\n        ? {\r\n            error: \"Longitude out of bounds\",\r\n          }\r\n        : func(data.lon, options);\r\n\r\n    if (!options.continueOnError) {\r\n      if (lat.error) throw lat.error;\r\n      if (lon.error) throw lon.error;\r\n    }\r\n    return options.flatten ? [lat, lon] : { lat, lon };\r\n  } else {\r\n    return options.flatten\r\n      ? Object.keys(data).map((item) => func(data[item], options))\r\n      : Object.keys(data).reduce((obj, item) => {\r\n          obj[item] = func(data[item], options);\r\n          return obj;\r\n        }, {});\r\n  }\r\n};\r\n\r\nmodule.exports = processPointObject;\r\n","const validateDMSstring = require(\"./validateDMSString\");\r\nconst processDMSstring = require(\"./processDMSstring\");\r\n\r\nconst processDMS = (position, options) => {\r\n  try {\r\n    //Check for any illegal characters\r\n    if (/[^0-9.,NSEW\\-\\s\\u00B0\\'\\\"]/i.test(position))\r\n      throw \"Malformed Position Data\";\r\n\r\n    //Check position is already a decimal and less than max longitude\r\n    if (\r\n      !isNaN(parseFloat(position)) &&\r\n      isFinite(position) &&\r\n      Math.abs(position)\r\n    ) {\r\n      if (Math.abs(position) > 180) throw \"Position Out of Bounds\";\r\n\r\n      return Number(position);\r\n    }\r\n\r\n    let deg,\r\n      dms = position\r\n        .replace(/^-/, \"\")\r\n        .replace(/[NSEW]/i, \"\") // strip off any sign or compass dir'n\r\n        .split(/[^0-9.,]+/); // split out separate d/m/s\r\n\r\n    //If find '' anywhere but at end of array then malformed data exists so throw error\r\n    dms.forEach((e, i) => {\r\n      if (e == \"\") {\r\n        if (i < dms.length - 1) {\r\n          throw \"Malformed Position Data\";\r\n        }\r\n        dms.splice(i, 1);\r\n      }\r\n    });\r\n\r\n    validateDMSstring(position, dms);\r\n    deg = processDMSstring(dms);\r\n\r\n    if (/^-/.test(position) || /[WS]/i.test(position)) deg = -deg; // take '-', west and south as -ve\r\n    return deg.toFixedNumber(7);\r\n  } catch (err) {\r\n    if (options.continueOnError) return { error: err };\r\n    throw err;\r\n  }\r\n};\r\n\r\nmodule.exports = processDMS;\r\n","/**\r\n * validateDMSstring\r\n *\r\n * Checks parsed DMS array for any element out of bounds.  Uses regex\r\n * on original string to look for NS to see if item is Lat or Lon\r\n *\r\n * @param {string} dmsString - Original string position\r\n * @param {array} dmsArray - Array of parsed string into elements [Degrees, Minutes, Seconds]\r\n *  @return {null | Error } returns error if item out of bounds or malformed\r\n */\r\nconst validateDMSstring = (dmsString, dmsArray) => {\r\n  //check deg boundaries\r\n  if (Math.abs(dmsArray[0]) > 180) throw \"DMS degrees out of bounds\";\r\n\r\n  if (/[NS]/i.test(dmsString) && Math.abs(dmsArray[0]) > 90)\r\n    throw \"DMS degrees out of bounds\";\r\n\r\n  switch (\r\n    dmsArray.length // convert to decimal degrees...\r\n  ) {\r\n    case 3: // interpret 3-part result as d/m/s\r\n      if (dmsArray[1] > 60) throw \"DMS minutes out of bounds\";\r\n\r\n      if (dmsArray[2] > 60) throw \"DMS seconds out of bounds\";\r\n\r\n    case 2: // interpret 2-part result as d/m\r\n      if (dmsArray[1] > 60) throw \"DMS minutes out of bounds\";\r\n\r\n    default:\r\n      return;\r\n  }\r\n};\r\n\r\nmodule.exports = validateDMSstring;\r\n","const processDMSstring = (dms) => {\r\n  let deg;\r\n  switch (\r\n    dms.length // convert to decimal degrees...\r\n  ) {\r\n    case 3: // interpret 3-part result as d/m/s\r\n      deg = dms[0] / 1 + dms[1] / 60 + dms[2] / 3600;\r\n      break;\r\n    case 2: // interpret 2-part result as d/m\r\n      deg = dms[0] / 1 + dms[1] / 60;\r\n      break;\r\n    case 1: // decimal or non-separated dddmmss\r\n      deg =\r\n        dms[0].slice(0, 3) / 1 +\r\n        dms[0].slice(3, 5) / 60 +\r\n        dms[0].slice(5) / 3600;\r\n      break;\r\n    default:\r\n      throw \"Malformed Position Data\";\r\n  }\r\n\r\n  return deg;\r\n};\r\n\r\nmodule.exports = processDMSstring;\r\n","const parseDMS = require(\"./parseDMS\");\r\nrequire(\"./prototypes\");\r\n\r\nconst handleError = (message) => {\r\n  throw { error: \"Invalid Bearings\", message };\r\n};\r\n\r\n/**\r\n * Inspects array of bearings and returns array of items that are not valid bearing values.\r\n * If all values are valid then returns an array with length 0\r\n * @param {array} bearings\r\n * @param {bool} allowString - bool that determeins is a string that parses to a number is allowed.  Default - false\r\n *\r\n * @return {array} - If there are bad bearings then returns array of objects that containe the index and value\r\n *  @param {number} index - Index of bad item\r\n *  @param {!number} value - Any value that does not parse to a number\r\n */\r\nconst validateBearings = (bearings, allowString) => {\r\n  let results = [];\r\n  bearings.forEach(function (bearing, i) {\r\n    if (isNaN(bearing) || bearing >= 360 || bearing < 0 || bearing === null)\r\n      return results.push({\r\n        index: i,\r\n        value: bearing,\r\n      });\r\n\r\n    if (!allowString && typeof bearing === \"string\")\r\n      results.push({\r\n        index: i,\r\n        value: bearing,\r\n      });\r\n  });\r\n\r\n  return results;\r\n};\r\n\r\nmodule.exports = {\r\n  /*------------------------------------------\r\n\r\n        COMPASS HEADING AND ANGLE FUNCTIONS\r\n\r\n    -------------------------------------------*/\r\n\r\n  validateBearings,\r\n  /**\r\n   * getAvgOfBearings\r\n   *\r\n   * Return average of all elements in array normalized for compass bearings.\r\n   * Numbers must be converted to radians and then compared\r\n   *\r\n   * @param {array} bearings - array of bearing values\r\n   * @returns {object}\r\n   * @param {number} degrees - the average of bearings in degrees\r\n   * @param {number} radians - the average of bearings in radians -\r\n   *\r\n   * Legitimate values are between 0 and 360 - not inclusive of 360, i.e. 359.99999\r\n   */\r\n  getAvgOfBearings: (bearings) => {\r\n    try {\r\n      if (bearings.length < 2) throw handleError(\"Less than two bearings\");\r\n\r\n      //check for malformed data\r\n      let checkBearings = validateBearings(bearings);\r\n      if (checkBearings.length > 0) throw checkBearings;\r\n\r\n      let values = bearings.reduce(\r\n        function (a, c) {\r\n          return {\r\n            sinValue: (a.sinValue += Math.sin(c.toRad())),\r\n            cosValue: (a.cosValue += Math.cos(c.toRad())),\r\n          };\r\n        },\r\n        { sinValue: 0, cosValue: 0 }\r\n      );\r\n\r\n      let bearingInRad = Math.atan2(values.sinValue, values.cosValue);\r\n      let bearingInDeg = bearingInRad.toDeg();\r\n\r\n      if (bearingInDeg <= -1) bearingInDeg += 359;\r\n\r\n      return {\r\n        degrees: Math.abs(Math.round(bearingInDeg * 100) / 100),\r\n        radians: bearingInRad,\r\n      };\r\n    } catch (err) {\r\n      handleError(err);\r\n    }\r\n  },\r\n\r\n  /**\r\n    getBearingBetweenTwoPoints\r\n\r\n    Calculate bearing between two positions\r\n\r\n    @param {object} start - GPS position\r\n      @param {number} start.lat\r\n      @param {number} start.lon\r\n    @param {object} end - GPS position\r\n      @param {number} end.lat\r\n      @param {number} end.lon\r\n    @param {number} decimal - number decimal places, default 0\r\n    @return {Number | Error} \r\n\r\n  */\r\n  getBearingBetweenTwoPoints: (start, end, decimal = 0) => {\r\n    try {\r\n      const [startClean, endClean] = parseDMS([start, end]);\r\n\r\n      let startLat = startClean.lat.toRad();\r\n      let endLat = endClean.lat.toRad();\r\n      let lonDiff = (endClean.lon - startClean.lon).toRad();\r\n\r\n      let y = Math.sin(lonDiff) * Math.cos(endLat);\r\n      let x =\r\n        Math.cos(startLat) * Math.sin(endLat) -\r\n        Math.sin(startLat) * Math.cos(endLat) * Math.cos(lonDiff);\r\n\r\n      return ((Math.atan2(y, x).toDeg() + 360) % 360).toFixedNumber(decimal);\r\n    } catch (err) {\r\n      throw err;\r\n    }\r\n  },\r\n\r\n  /**\r\n    getBearingDiff\r\n\r\n    Calculate normalized difference between two bearings.  This return the smallest arc of\r\n    two possible as use case for this will always be the smaller of two arcs\r\n\r\n    @param {number} bearing1\r\n    @param {number} bearing2\r\n\r\n    @return {number}\r\n\r\n  */\r\n  getBearingDiff: (bearing1, bearing2) => {\r\n    if (bearing1 >= 360 || bearing1 < 0 || bearing2 >= 360 || bearing2 < 0)\r\n      handleError(\"Out of bounds\");\r\n\r\n    return Math.min(\r\n      bearing1 - bearing2 < 0 ? bearing1 - bearing2 + 360 : bearing1 - bearing2,\r\n      bearing2 - bearing1 < 0 ? bearing2 - bearing1 + 360 : bearing2 - bearing1\r\n    );\r\n  },\r\n\r\n  /**\r\n    addHeading\r\n\r\n    Adds and normalizes two bearings\r\n\r\n    @param {number} baseHdg\r\n    @param {number} addDegrees\r\n\r\n    @return {number} new bearing\r\n\r\n  */\r\n  addHeading: (baseHdg, addDegrees) => {\r\n    hdg = baseHdg + addDegrees;\r\n    if (hdg < 0) {\r\n      hdg += 360;\r\n    }\r\n    if (hdg >= 360) {\r\n      hdg -= 360;\r\n    }\r\n\r\n    return hdg;\r\n  },\r\n\r\n  /**\r\n    invertHDG\r\n\r\n    Inverts and normalizes heading\r\n\r\n    @param {number} hdg\r\n    @return {number} new bearing\r\n\r\n  */\r\n  invertHDG: (hdg) => {\r\n    hdg += 180; //quadrant orientaion\r\n    if (hdg < 0) {\r\n      hdg += 360;\r\n    }\r\n    if (hdg >= 360) {\r\n      hdg -= 360;\r\n    }\r\n\r\n    return hdg;\r\n  },\r\n\r\n  /**\r\n    findMiddleAngle\r\n\r\n    Calculates difference in two bearings and returns median bearing between those two bearings\r\n    Effectively finds the smaller of the two angles of a cricle and returns the median angle\r\n\r\n    @param {number} startAngle\r\n    @param {number} endAngle\r\n\r\n    @return {number} median bearing\r\n\r\n  */\r\n  findMiddleAngle: (startAngle, endAngle) => {\r\n    startAngle = Math.round(startAngle);\r\n    endAngle = Math.round(endAngle);\r\n\r\n    let bearingdiff = this.getBearingDiff(startAngle, endAngle);\r\n\r\n    if (this.addHeading(startAngle, bearingdiff) == endAngle) {\r\n      return this.addHeading(startAngle, bearingdiff / 2);\r\n    } else {\r\n      return this.addHeading(startAngle, (bearingdiff * -1) / 2);\r\n    }\r\n  },\r\n};\r\n","/**\r\n      Get min, max, avg of a given property from array and filters out non numbers or bad data\r\n\r\n      @param {object} arrs\r\n        @property {array} array - Array of racedata objects to get min,max, avg from\r\n        @property {object} dataSource - propery of racedata object to use as basis for reducing array\r\n\r\n      @returns {object}\r\n        @property {number} max\r\n        @property {number} min\r\n        @property {number} avg\r\n\r\n    */\r\nconst getMinMaxAvgFromArray = (newArray) => {\r\n  //strips out bad data\r\n  let max = newArray.reduce(function (a, b) {\r\n    if (isNaN(a) || a === null || a === \"\") a = -Infinity;\r\n    if (isNaN(b) || b === null || b === \"\") b = -Infinity;\r\n    return Math.max(a, b);\r\n  }, -Infinity);\r\n\r\n  let min = newArray.reduce(function (a, b) {\r\n    if (isNaN(a) || a === null || a === \"\") a = Infinity;\r\n    if (isNaN(b) || b === null || b === \"\") b = Infinity;\r\n    return Math.min(a, b);\r\n  }, Infinity);\r\n\r\n  let avg =\r\n    newArray.reduce(function (previous, current) {\r\n      if (isNaN(current) || current === null || current === \"\") return previous;\r\n      return previous + Number(current);\r\n    }, 0) / newArray.length;\r\n\r\n  return { min, max, avg };\r\n};\r\n\r\n/**\r\n * getBoundsOfData\r\n *\r\n * Takes an array of geoJSON objects and returns a boundary box containeing those values\r\n * @param {array} data array of geoJSON object\r\n * @param {object} geoJSON\r\n * @property {number} lat\r\n * @property {number} lon\r\n *\r\n * @returns {object} Return object has four cornes of bounds of data set\r\n * @property {latMin} latMin\r\n * @property {latMax} latMax\r\n * @property {lonMin}\r\n * @property {lonMax}\r\n */\r\nconst getBoundsOfData = (data) => {\r\n  const boundsObject = data.reduce(\r\n    function (a, c) {\r\n      return {\r\n        latMin: isNaN(a.latMin) || a.latMin > c.lat ? c.lat : a.latMin,\r\n        latMax: isNaN(a.latMax) || a.latMax < c.lat ? c.lat : a.latMax,\r\n        lngMin: isNaN(a.lngMin) || a.lngMin > c.lng ? c.lng : a.lngMin,\r\n        lngMax: isNaN(a.lngMax) || a.lngMax < c.lng ? c.lng : a.lngMax,\r\n      };\r\n    },\r\n    {\r\n      latMin: Infinity,\r\n      latMax: -Infinity,\r\n      lngMin: Infinity,\r\n      lngMax: -Infinity,\r\n    }\r\n  );\r\n};\r\n\r\nmodule.exports = { getMinMaxAvgFromArray, getBoundsOfData };\r\n","/**\r\n    getDistanceCos\r\n\r\n    Calculate distance between two points in km.  This method generates more accurate distance for points close together\r\n    like within a tunr or on a race course\r\n\r\n    @param {object} from - GPS position\r\n      @property {number} lat\r\n      @property {number} lon\r\n    @param {object} to - GPS position\r\n      @property {number} lat\r\n      @property {number} lon\r\n    @return {Number} - km [default]\r\n\r\n  */\r\nconst getDistanceCos = (from, to, radius) => {\r\n  let R = radius || geo_const.MEAN_RADIUS_IN_M / 1000; //default to earth radius in km\r\n\r\n  let d =\r\n    Math.acos(\r\n      Math.sin((from.lat * Math.PI) / 180) *\r\n        Math.sin((to.lat * Math.PI) / 180) +\r\n        Math.cos((from.lat * Math.PI) / 180) *\r\n          Math.cos((to.lat * Math.PI) / 180) *\r\n          Math.cos(((to.lon - from.lon) * Math.PI) / 180)\r\n    ) * R;\r\n  return d;\r\n};\r\n\r\n/**\r\n    getDistanceHaversine\r\n\r\n    Calculate distance between two points.  This method generates more accurate distance for points farther apart\r\n    and incorporates the curve of the earth as part of the equation\r\n\r\n    @param {object} from - GPS position\r\n      @property {number} lat\r\n      @property {number} lon\r\n    @param {object} to - GPS position\r\n      @property {number} lat\r\n      @property {number} lon\r\n    @return {Number}\r\n\r\n  */\r\nconst getDistanceHaversine = (from, to) => {\r\n  let R = geo_const.MEAN_RADIUS_IN_M / 1000; // earth's mean radius in km\r\n  let dLat = ((to.lat - from.lat) * Math.PI) / 180;\r\n  let dLon = ((to.lon - from.lon) * Math.PI) / 180;\r\n  from.lat = (from.lat * Math.PI) / 180;\r\n  to.lat = (to.lat * Math.PI) / 180;\r\n\r\n  let a =\r\n    Math.sin(dLat / 2) * Math.sin(dLat / 2) +\r\n    Math.cos(from.lat) *\r\n      Math.cos(to.lat) *\r\n      Math.sin(dLon / 2) *\r\n      Math.sin(dLon / 2);\r\n  let c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n  let d = R * c;\r\n  return d;\r\n};\r\n\r\n/**\r\n * getDistanceFromSpeedTime\r\n *\r\n * Calculate distance from speed (in kM/hour) and Time (seconds)\r\n *\r\n * @param {number} speed - speed in kM/hr\r\n * @param {number} time - time in Seconds\r\n * @return {object}\r\n *      @property {number} distInDegree\r\n *      @property {number} distInFeet\r\n *      @property {number} distInKilometers\r\n *\r\n * */\r\n\r\nconst getDistanceFromSpeedTime = (speed, time) => {\r\n  return {\r\n    distInDegree: (speed * (time / geo_const.HOUR)) / geo_const.KM_IN_DEG,\r\n    distInFeet: speed * (time / geo_const.HOUR) * geo_const.KM_TO_FEET,\r\n    distInKilometers: speed * (time / geo_const.HOUR),\r\n    distInNM: speed * (time / geo_const.HOUR) * geo_const.KM_TO_NM,\r\n  };\r\n};\r\n\r\n/**\r\n   * Returns (signed) distance from ‘this’ point to great circle defined by start-point and end-point.\r\n   *\r\n   * @param   {object} lineStart - Start point of great circle path.\r\n       @param {number} lat\r\n       @param {number} lon\r\n   * @param   {object} lineEnd - End point of great circle path.\r\n       @param {number} lat\r\n       @param {number} lon\r\n     @param   {object} currentPoint -current location\r\n         @param {number} lat\r\n         @param {number} lon\r\n   * @param   {bool} haversine - use haversine versus cosine calculation.  Cos is best for smalelr distances \r\n   * @returns {number} Distance to great circle (-ve if to left, +ve if to right of path).\r\n   *    *    \r\n   */\r\nfunction crossTrackDistanceTo({\r\n  lineStart,\r\n  lineEnd,\r\n  currentPoint,\r\n  haversine = false,\r\n}) {\r\n  let lineLength = haversine\r\n    ? this.getDistanceHaversine(\r\n        lineStart,\r\n        currentPoint,\r\n        geo_const.MEAN_RADIUS_IN_M\r\n      ) / geo_const.MEAN_RADIUS_IN_M\r\n    : this.getDistanceCos(lineStart, currentPoint, geo_const.MEAN_RADIUS_IN_M) /\r\n      geo_const.MEAN_RADIUS_IN_M;\r\n\r\n  let startToCurrent =\r\n    this.getBearingBetweenTwoPoints(lineStart, currentPoint) * (Math.PI / 180);\r\n\r\n  let startLineBearing =\r\n    this.getBearingBetweenTwoPoints(lineStart, lineEnd) * (Math.PI / 180);\r\n\r\n  let XTE = Math.asin(\r\n    Math.sin(lineLength) * Math.sin(startToCurrent - startLineBearing)\r\n  );\r\n\r\n  return XTE * geo_const.MEAN_RADIUS_IN_M;\r\n}\r\n\r\nmodule.exports = {\r\n  getDistanceCos,\r\n  getDistanceHaversine,\r\n  getDistanceFromSpeedTime,\r\n  crossTrackDistanceTo,\r\n};\r\n","const getPostionFromBearingAndDistance = (waypoint, distance, bearing) => {\r\n  let position = {\r\n    lat: waypoint.lat(),\r\n    lng: waypoint.lng(),\r\n  };\r\n\r\n  dist = distance / geo_const.MEAN_RADIUS_IN_M / 1000;\r\n\r\n  let brng = (Number(bearing) * Math.PI) / 180;\r\n  let lat1 = position.lat;\r\n  lat1 = (lat1 * Math.PI) / 180;\r\n  let lon1 = position.lng;\r\n  lon1 = (lon1 * Math.PI) / 180;\r\n\r\n  let lat2 = Math.asin(\r\n    Math.sin(lat1) * Math.cos(dist) +\r\n      Math.cos(lat1) * Math.sin(dist) * Math.cos(brng)\r\n  );\r\n\r\n  let lon2 =\r\n    lon1 +\r\n    Math.atan2(\r\n      Math.sin(brng) * Math.sin(dist) * Math.cos(lat1),\r\n      Math.cos(dist) - Math.sin(lat1) * Math.sin(lat2)\r\n    );\r\n\r\n  return {\r\n    lat: (lat2 * 180) / Math.PI,\r\n    lng: (lon2 * 180) / Math.PI,\r\n  };\r\n};\r\n\r\n/**\r\n    getIntersection\r\n\r\n    Calculate intersection point between two lines/routes in lat and lon.  They are not required to overlap to calulate\r\n\r\n   \r\n      @property {object} lineA\r\n        @property {number} lat\r\n        @property {number} lon\r\n\r\n      @property {object} lineB\r\n        @property {number} lat\r\n        @property {number} lon\r\n\r\n\r\n    @return {object}\r\n      @property {number} lat\r\n      @property {number} lon\r\n\r\n  */\r\nconst getIntersectionPoint = ({ lineA, lineB }) => {\r\n  let XAsum = lineA.start.lon - lineA.end.lon;\r\n  let XBsum = lineB.start.lon - lineB.end.lon;\r\n  let YAsum = lineA.start.lat - lineA.end.lat;\r\n  let YBsum = lineB.start.lat - lineB.end.lat;\r\n\r\n  let lineDenominator = XAsum * YBsum - YAsum * XBsum;\r\n  if (lineDenominator == 0.0) return false;\r\n\r\n  let a =\r\n    lineA.start.lon * lineA.end.lat - arrs.lineA.start.lat * lineA.end.lon;\r\n  let b = lineB.start.lon * lineB.end.lat - lineB.start.lat * lineB.end.lon;\r\n\r\n  let lat = (a * YBsum - b * YAsum) / lineDenominator;\r\n  let lon = (a * XBsum - b * XAsum) / lineDenominator;\r\n\r\n  return { lat, lon };\r\n};\r\n\r\n/**\r\n * Convert lat/lon to mercator projection points\r\n */\r\nconst mercator = ({ latitude, longitude }) => {\r\n  const MAX = 85.0511287798;\r\n  const RADIANS = Math.PI / 180;\r\n  let point = {};\r\n\r\n  point.lon = geo_const.RADIUS_IN_M * longitude * RADIANS;\r\n  point.lat = Math.max(Math.min(MAX, latitude), -MAX) * RADIANS;\r\n  point.lat =\r\n    geo_const.RADIUS_IN_M * Math.log(Math.tan(Math.PI / 4 + point.lat / 2));\r\n\r\n  return point;\r\n};\r\n\r\nmodule.exports = {\r\n  getIntersectionPoint,\r\n  getPostionFromBearingAndDistance,\r\n  mercator,\r\n};\r\n","/**\r\n * humanTime\r\n *\r\n * Produce human readable time from milliseconds.  Automatically hide/add mins secs days etc\r\n *\r\n */\r\nconst humanTime = (millisec) => {\r\n  let seconds = (millisec / 1000).toFixed(0);\r\n  let minutes = Math.floor(seconds / 60);\r\n  let hours = \"\";\r\n  if (minutes > 59) {\r\n    hours = Math.floor(minutes / 60);\r\n    hours = hours >= 10 ? hours : \"0\" + hours;\r\n    minutes = minutes - hours * 60;\r\n    minutes = minutes >= 10 ? minutes : \"0\" + minutes;\r\n  }\r\n\r\n  seconds = Math.floor(seconds % 60);\r\n  seconds = seconds >= 10 ? seconds : \"0\" + seconds;\r\n  if (hours != \"\") {\r\n    return hours + \":\" + minutes + \":\" + seconds;\r\n  }\r\n  return minutes + \":\" + seconds;\r\n};\r\n\r\nmodule.exports = { humanTime };\r\n","/**\r\n  GDouglasPeucker\r\n  Stack-based Douglas Peucker line simplification routine\r\n   returned is a reduced google.maps.LatLng array\r\n   After code by  Dr. Gary J. Robinson,\r\n   Environmental Systems Science Centre,\r\n   University of Reading, Reading, UK\r\n\r\n   @param {array} source Input coordinates\r\n   @param {number} kink in metres, kinks above this depth kept.  Kink depth is the height of the triangle abc where a-b and b-c are two consecutive line segments\r\n\r\n*/\r\n\r\nfunction GDP_smoother(source, kink) {\r\n  let n_source, n_stack, n_dest, start, end, i, sig;\r\n  let dev_sqr, max_dev_sqr, band_sqr;\r\n  let x12, y12, d12, x13, y13, d13, x23, y23, d23;\r\n  let F = (Math.PI / 180.0) * 0.5;\r\n  let index = new Array(); /* aray of indexes of source points to include in the reduced line */\r\n  let sig_start = new Array(); /* indices of start & end of working section */\r\n  let sig_end = new Array();\r\n\r\n  /* check for simple cases */\r\n\r\n  if (source.length < 3) return source; /* one or two points */\r\n\r\n  /* more complex case. initialize stack */\r\n\r\n  n_source = source.length;\r\n  band_sqr = (kink * 360.0) / (2.0 * Math.PI * 6378137.0); /* Now in degrees */\r\n  band_sqr *= band_sqr;\r\n  n_dest = 0;\r\n  sig_start[0] = 0;\r\n  sig_end[0] = n_source - 1;\r\n  n_stack = 1;\r\n\r\n  /* while the stack is not empty  ... */\r\n  while (n_stack > 0) {\r\n    /* ... pop the top-most entries off the stacks */\r\n\r\n    start = sig_start[n_stack - 1];\r\n    end = sig_end[n_stack - 1];\r\n    n_stack--;\r\n\r\n    if (end - start > 1) {\r\n      /* any intermediate points ? */\r\n\r\n      /* ... yes, so find most deviant intermediate point to\r\n                     either side of line joining start & end points */\r\n\r\n      x12 = source[end].lon - source[start].lon;\r\n      y12 = source[end].lat - source[start].lat;\r\n      if (Math.abs(x12) > 180.0) x12 = 360.0 - Math.abs(x12);\r\n      x12 *= Math.cos(\r\n        F * (source[end].lat + source[start].lat)\r\n      ); /* use avg lat to reduce lon */\r\n      d12 = x12 * x12 + y12 * y12;\r\n\r\n      for (i = start + 1, sig = start, max_dev_sqr = -1.0; i < end; i++) {\r\n        x13 = source[i].lon - source[start].lon;\r\n        y13 = source[i].lat - source[start].lat;\r\n        if (Math.abs(x13) > 180.0) x13 = 360.0 - Math.abs(x13);\r\n        x13 *= Math.cos(F * (source[i].lat + source[start].lat));\r\n        d13 = x13 * x13 + y13 * y13;\r\n\r\n        x23 = source[i].lon - source[end].lon;\r\n        y23 = source[i].lat - source[end].lat;\r\n        if (Math.abs(x23) > 180.0) x23 = 360.0 - Math.abs(x23);\r\n        x23 *= Math.cos(F * (source[i].lat + source[end].lat));\r\n        d23 = x23 * x23 + y23 * y23;\r\n\r\n        if (d13 >= d12 + d23) dev_sqr = d23;\r\n        else if (d23 >= d12 + d13) dev_sqr = d13;\r\n        else\r\n          dev_sqr = ((x13 * y12 - y13 * x12) * (x13 * y12 - y13 * x12)) / d12; // solve triangle\r\n\r\n        if (dev_sqr > max_dev_sqr) {\r\n          sig = i;\r\n          max_dev_sqr = dev_sqr;\r\n        }\r\n      }\r\n\r\n      if (max_dev_sqr < band_sqr) {\r\n        /* is there a sig. intermediate point ? */\r\n        /* ... no, so transfer current start point */\r\n        index[n_dest] = start;\r\n        n_dest++;\r\n      } else {\r\n        /* ... yes, so push two sub-sections on stack for further processing */\r\n        n_stack++;\r\n        sig_start[n_stack - 1] = sig;\r\n        sig_end[n_stack - 1] = end;\r\n        n_stack++;\r\n        sig_start[n_stack - 1] = start;\r\n        sig_end[n_stack - 1] = sig;\r\n      }\r\n    } else {\r\n      /* ... no intermediate points, so transfer current start point */\r\n      index[n_dest] = start;\r\n      n_dest++;\r\n    }\r\n  }\r\n\r\n  /* transfer last point */\r\n  index[n_dest] = n_source - 1;\r\n  n_dest++;\r\n\r\n  /* make return array */\r\n  let r = new Array();\r\n  for (let i = 0; i < n_dest; i++) r.push(source[index[i]]);\r\n\r\n  return r;\r\n}\r\n\r\nmodule.exports = { GDP_smoother };\r\n"],"sourceRoot":""}