{"version":3,"sources":["webpack://geo/webpack/universalModuleDefinition","webpack://geo/webpack/bootstrap","webpack://geo/./src/index.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;QCVA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;;AAE/B;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0DAA0D;AAC1D;;AAEA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8DAA8D;AAC9D,uCAAuC;AACvC,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,eAAe;AACf,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA,qCAAqC;;AAErC;AACA;AACA,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,OAAO;AACP;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,YAAY,OAAO;AACnB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,YAAY,OAAO;AACnB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,aAAa;;AAEb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,YAAY,OAAO;AACnB,YAAY,OAAO;;AAEnB,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,YAAY,OAAO;AACnB,YAAY,OAAO;;AAEnB,aAAa,OAAO;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,YAAY,OAAO;AACnB,aAAa,OAAO;;AAEpB;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,YAAY,OAAO;AACnB,YAAY,OAAO;;AAEnB,aAAa,OAAO;;AAEpB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,OAAO;AACpB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB;AACA,eAAe,OAAO;AACtB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB;AAChB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,YAAY,OAAO;AACnB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,YAAY,OAAO;AACnB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,aAAa,OAAO;;AAEpB;AACA;AACA,8CAA8C;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,YAAY,OAAO;AACnB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,YAAY,OAAO;AACnB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,aAAa;;AAEb;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc;AACd,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,YAAY,OAAO;AACnB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;;AAExB,aAAa;AACb,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;;AAExB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;AAGA,iBAAiB,OAAO;AACxB,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;;AAE1B,iBAAiB,OAAO;AACxB,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;;;AAG1B,aAAa;AACb,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;;AAExB;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,YAAY;AACZ;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,eAAe,KAAK;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,cAAc,OAAO;AACrB,mBAAmB,MAAM;AACzB,mBAAmB,OAAO;;AAE1B,gBAAgB;AAChB,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP,YAAY;AACZ;;AAEA;AACA;AACA;AACA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,MAAM;AACjB,WAAW,OAAO;;AAElB;;AAEA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,gCAAgC;AAChC;;AAEA;;AAEA,yCAAyC;;AAEzC;;AAEA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA,4DAA4D,SAAS;AACrE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gFAAgF;;AAEhF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,YAAY;;AAE/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","file":"geo.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"geo\"] = factory();\n\telse\n\t\troot[\"geo\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","module.exports = (() => {\n  //constants\n  const KM_TO_NM = 0.539957,\n    NM_TO_KM = 1.852,\n    HOUR = 3600,\n    KM_IN_DEG = 111.12,\n    NM_IN_DEG = 60,\n    NM_TO_FEET = 6076,\n    KM_TO_FEET = 3280.84,\n    RADIUS_IN_M = 6378137, //radius earth at equator\n    MEAN_RADIUS_IM_M = 6371000; //earth mean radius\n\n  /**\n   * Inspects array of bearings and returns array of items that are not valid bearing values.\n   * If all values are valid then returns an array with length 0\n   * @param {array} bearings\n   */\n  _checkBearings = (bearings) => {\n    let results = [];\n    bearings.forEach(function (bearing, i) {\n      if (isNaN(bearing) || bearing >= 360 || bearing < 0)\n        results.push({\n          index: i,\n          value: bearing,\n        });\n    });\n\n    return results;\n  };\n\n  // extend Number object with methods for converting degrees/radians\n\n  Number.prototype.toRad = function () {\n    // convert degrees to radians\n    return (this * Math.PI) / 180;\n  };\n\n  Number.prototype.toDeg = function () {\n    // convert radians to degrees (signed)\n    return (this * 180) / Math.PI;\n  };\n\n  Number.prototype.toBrng = function () {\n    // convert radians to degrees (as bearing: 0...360)\n    return (this.toDeg() + 360) % 360;\n  };\n\n  Number.prototype.toDMS = function () {\n    // convert numeric degrees to deg/min/sec\n    let d = Math.abs(this);\n    d += 1 / 7200; // add to second for rounding\n    let deg = Math.floor(d);\n    let min = Math.floor((d - deg) * 60);\n    let sec = Math.floor((d - deg - min / 60) * 3600);\n\n    // add leading zeros if required\n    if (deg < 100) deg = \"0\" + deg;\n    if (deg < 10) deg = \"0\" + deg;\n    if (min < 10) min = \"0\" + min;\n    if (sec < 10) sec = \"0\" + sec;\n    return deg + \"\\u00B0\" + min + \"\\u2032\" + sec + \"\\u2033\";\n  };\n\n  Number.prototype.toLat = function () {\n    // convert numeric degrees to deg/min/sec latitude\n    return this.toDMS().slice(1) + (this < 0 ? \"S\" : \"N\"); // knock off initial '0' for lat\n  };\n\n  Number.prototype.toLon = function () {\n    // convert numeric degrees to deg/min/sec longitude\n    return this.toDMS() + (this > 0 ? \"E\" : \"W\");\n  };\n\n  Number.prototype.toPrecision = function (fig) {\n    if (this == 0) return 0; // trailing zeros in place of exponential notation\n    let scale = Math.ceil(Math.log(this) * Math.LOG10E);\n    let mult = Math.pow(10, fig - scale);\n    return Math.round(this * mult) / mult;\n  };\n\n  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n  /**\n   * Adapted from Chris Veness\n   * http://www.movable-type.co.uk/scripts/latlong.htmlarses string representing degrees/minutes/seconds into numeric degrees.\n   *\n   * This is very flexible on formats, allowing signed decimal degrees, or deg-min-sec optionally\n   * suffixed by compass direction (NSEW); a variety of separators are accepted. Examples -3.62,\n   * '3 37 12W', '3°37′12″W'.\n   *\n   * Thousands/decimal separators must be comma/dot; use Dms.fromLocale to convert locale-specific\n   * thousands/decimal separators.\n   *\n   * @example\n   *   '53° 18′ 20.22″ N'.parseDeg() =\n   *\n   */\n\n  String.prototype.parseDMS = function () {\n    if (!isNaN(parseFloat(this)) && isFinite(this)) return Number(this);\n    let deg;\n    let degLL = this.replace(/^-/, \"\").replace(/[NSEW]/i, \"\"); // strip off any sign or compass dir'n\n    let dms = degLL.split(/[^0-9.,]+/); // split out separate d/m/s\n    for (let i in dms) if (dms[i] == \"\") dms.splice(i, 1); // remove empty elements (see note below)\n    switch (\n      dms.length // convert to decimal degrees...\n    ) {\n      case 3: // interpret 3-part result as d/m/s\n        deg = dms[0] / 1 + dms[1] / 60 + dms[2] / 3600;\n        break;\n      case 2: // interpret 2-part result as d/m\n        deg = dms[0] / 1 + dms[1] / 60;\n        break;\n      case 1: // decimal or non-separated dddmmss\n        if (/[NS]/i.test(this)) degLL = \"0\" + degLL; // - normalise N/S to 3-digit degrees\n        deg =\n          dms[0].slice(0, 3) / 1 +\n          dms[0].slice(3, 5) / 60 +\n          dms[0].slice(5) / 3600;\n        break;\n      default:\n        return NaN;\n    }\n    if (/^-/.test(this) || /[WS]/i.test(this)) deg = -deg; // take '-', west and south as -ve\n    return deg;\n  };\n\n  /*------------------------------------------\n\n        COMPASS HEADING AND ANGLE FUNCTIONS\n\n    -------------------------------------------*/\n\n  /**\n   * getAvgOfBearings\n   *\n   * Return average of all elements in array normalized for compass bearings.\n   * Numbers must be converted to radians and then compared\n   *\n   * @param {array} bearings - array of bearing values\n   * @returns {object}\n   * @param {number} degrees - the average of bearings in degrees\n   * @param {number} radians - the average of bearings in radians -\n   *\n   * Legitimate values are between 0 and 360 - not inclusive of 360, i.e. 359.99999\n   */\n  const getAvgOfBearings = (bearings) => {\n    if (bearings.length < 2) return { error: \"Less than two bearings\" };\n\n    let checkBearings = _checkBearings(bearings);\n    if (checkBearings.length > 0)\n      return { error: \"Invalid Bearings\", values: checkBearings };\n\n    let values = bearings.reduce(\n      function (a, c) {\n        return {\n          sinValue: (a.sinValue += Math.sin(c.toRad())),\n          cosValue: (a.cosValue += Math.cos(c.toRad())),\n        };\n      },\n      { sinValue: 0, cosValue: 0 }\n    );\n\n    let bearingInRad = Math.atan2(values.sinValue, values.cosValue);\n    let bearingInDeg = bearingInRad.toRad();\n\n    if (bearingInDeg <= -1) bearingInDeg += 359;\n\n    return {\n      degrees: Math.abs(Math.round(bearingInDeg * 100) / 100),\n      radians: bearingInRad,\n    };\n  };\n\n  /**\n    getBearingBetweenTwoPoints\n\n    Calculate bearing between two positions\n\n    @param {object} position1 - GPS position\n      @param {number} position1.lat\n      @param {number} position1.lon\n    @param {object} position2 - GPS position\n      @param {number} position2.lat\n      @param {number} position2.lon\n    @return {Number}\n\n  */\n  const getBearingBetweenTwoPoints = (position1, position2) => {\n    let pos1Lat = (position1.lat * Math.PI) / 180;\n    let pos2Lat = (position2.lat * Math.PI) / 180;\n    let dLon = ((position2.lon - position1.lon) * Math.PI) / 180;\n\n    let y = Math.sin(dLon) * Math.cos(pos2Lat);\n    let x =\n      Math.cos(pos1Lat) * Math.sin(pos2Lat) -\n      Math.sin(pos1Lat) * Math.cos(pos2Lat) * Math.cos(dLon);\n    return ((Math.atan2(y, x) * 180) / Math.PI + 360) % 360;\n  };\n\n  /**\n    getBearingDiff\n\n    Calculate normalized difference between two bearings\n\n    @param {number} bearing1\n    @param {number} bearing2\n\n    @return {number}\n\n  */\n  const getBearingDiff = (bearing1, bearing2) => {\n    return Math.min(\n      bearing1 - bearing2 < 0 ? bearing1 - bearing2 + 360 : bearing1 - bearing2,\n      bearing2 - bearing1 < 0 ? bearing2 - bearing1 + 360 : bearing2 - bearing1\n    );\n  };\n\n  /**\n    addHeading\n\n    Adds and normalizes two bearings\n\n    @param {number} baseHdg\n    @param {number} addDegrees\n\n    @return {number} new bearing\n\n  */\n  const addHeading = (baseHdg, addDegrees) => {\n    hdg = baseHdg + addDegrees;\n    if (hdg < 0) {\n      hdg += 360;\n    }\n    if (hdg >= 360) {\n      hdg -= 360;\n    }\n\n    return hdg;\n  };\n\n  /**\n    invertHDG\n\n    Inverts and normalizes heading\n\n    @param {number} hdg\n    @return {number} new bearing\n\n  */\n  const invertHDG = (hdg) => {\n    hdg += 180; //quadrant orientaion\n    if (hdg < 0) {\n      hdg += 360;\n    }\n    if (hdg >= 360) {\n      hdg -= 360;\n    }\n\n    return hdg;\n  };\n\n  /**\n    findMiddleAngle\n\n    Calculates difference in two bearings and returns median bearing between those two bearings\n    Effectively finds the smaller of the two angles of a cricle and returns the median angle\n\n    @param {number} startAngle\n    @param {number} endAngle\n\n    @return {number} median bearing\n\n  */\n  function findMiddleAngle(startAngle, endAngle) {\n    startAngle = Math.round(startAngle);\n    endAngle = Math.round(endAngle);\n\n    let bearingdiff = this.getBearingDiff(startAngle, endAngle);\n\n    if (this.addHeading(startAngle, bearingdiff) == endAngle) {\n      return this.addHeading(startAngle, bearingdiff / 2);\n    } else {\n      return this.addHeading(startAngle, (bearingdiff * -1) / 2);\n    }\n  }\n\n  /*------------------------------------------\n\n        GPS DATA \n\n    -------------------------------------------*/\n  /**\n    Parse Human readable GPS\n\n    Converts GPS\n  */\n  const parseDMS = (input) => {\n    return input.parseDMS();\n  };\n\n  /**\n   * getBoundsOfData\n   *\n   * Takes an array of geoJSON objects and returns a boundary box containeing those values\n   * @param {array} data array of geoJSON object\n   * @param {object} geoJSON\n   * @property {number} lat\n   * @property {number} lon\n   *\n   * @returns {object} Return object has four cornes of bounds of data set\n   * @property {latMin} latMin\n   * @property {latMax} latMax\n   * @property {lonMin}\n   * @property {lonMax}\n   */\n  const getBoundsOfData = (data) => {\n    const boundsObject = data.reduce(\n      function (a, c) {\n        return {\n          latMin: isNaN(a.latMin) || a.latMin > c.lat ? c.lat : a.latMin,\n          latMax: isNaN(a.latMax) || a.latMax < c.lat ? c.lat : a.latMax,\n          lngMin: isNaN(a.lngMin) || a.lngMin > c.lng ? c.lng : a.lngMin,\n          lngMax: isNaN(a.lngMax) || a.lngMax < c.lng ? c.lng : a.lngMax,\n        };\n      },\n      {\n        latMin: Infinity,\n        latMax: -Infinity,\n        lngMin: Infinity,\n        lngMax: -Infinity,\n      }\n    );\n  };\n\n  /*-------------------------------------------------------\n\n    DISTANCE FUNCTIONS\n\n  --------------------------------------------------------*/\n\n  /**\n    getDistanceCos\n\n    Calculate distance between two points in km.  This method generates more accurate distance for points close together\n    like within a tunr or on a race course\n\n    @param {object} from - GPS position\n      @property {number} lat\n      @property {number} lon\n    @param {object} to - GPS position\n      @property {number} lat\n      @property {number} lon\n    @return {Number} - km [default]\n\n  */\n  const getDistanceCos = (from, to, radius) => {\n    let R = radius || MEAN_RADIUS_IM_M / 1000; //default to earth radius in km\n\n    let d =\n      Math.acos(\n        Math.sin((from.lat * Math.PI) / 180) *\n          Math.sin((to.lat * Math.PI) / 180) +\n          Math.cos((from.lat * Math.PI) / 180) *\n            Math.cos((to.lat * Math.PI) / 180) *\n            Math.cos(((to.lon - from.lon) * Math.PI) / 180)\n      ) * R;\n    return d;\n  };\n\n  /**\n    getDistanceHaversine\n\n    Calculate distance between two points.  This method generates more accurate distance for points farther apart\n    and incorporates the curve of the earth as part of the equation\n\n    @param {object} from - GPS position\n      @property {number} lat\n      @property {number} lon\n    @param {object} to - GPS position\n      @property {number} lat\n      @property {number} lon\n    @return {Number}\n\n  */\n  const getDistanceHaversine = (from, to) => {\n    let R = MEAN_RADIUS_IM_M / 1000; // earth's mean radius in km\n    let dLat = ((to.lat - from.lat) * Math.PI) / 180;\n    let dLon = ((to.lon - from.lon) * Math.PI) / 180;\n    from.lat = (from.lat * Math.PI) / 180;\n    to.lat = (to.lat * Math.PI) / 180;\n\n    let a =\n      Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n      Math.cos(from.lat) *\n        Math.cos(to.lat) *\n        Math.sin(dLon / 2) *\n        Math.sin(dLon / 2);\n    let c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    let d = R * c;\n    return d;\n  };\n\n  /**\n   * getDistanceFromSpeedTime\n   *\n   * Calculate distance from speed (in kM/hour) and Time (seconds)\n   *\n   * @param {number} speed - speed in kM/hr\n   * @param {number} time - time in Seconds\n   * @return {object}\n   *      @property {number} distInDegree\n   *      @property {number} distInFeet\n   *      @property {number} distInKilometers\n   *\n   * */\n\n  const getDistanceFromSpeedTime = (speed, time) => {\n    return {\n      distInDegree: (speed * (time / HOUR)) / KM_IN_DEG,\n      distInFeet: speed * (time / HOUR) * KM_TO_FEET,\n      distInKilometers: speed * (time / HOUR),\n      distInNM: speed * (time / HOUR) * KM_TO_NM,\n    };\n  };\n\n  /**\n    getPostionFromBearingAndDistance\n\n    Calculate lat and lon point from existing point, bearing and distance.  Inputs in KM\n\n    @param {object} arrs -\n      @property {object} waypoint\n      @property {number} distance in km\n      @property {number} bearing\n\n    @return {object}\n      @property {number} lat - lat derived\n      @property {number} lng - lon derived\n\n  */\n\n  const getPostionFromBearingAndDistance = (waypoint, distance, bearing) => {\n    let position = {\n      lat: waypoint.lat(),\n      lng: waypoint.lng(),\n    };\n\n    dist = distance / MEAN_RADIUS_IM_M / 1000;\n\n    let brng = (Number(bearing) * Math.PI) / 180;\n    let lat1 = position.lat;\n    lat1 = (lat1 * Math.PI) / 180;\n    let lon1 = position.lng;\n    lon1 = (lon1 * Math.PI) / 180;\n\n    let lat2 = Math.asin(\n      Math.sin(lat1) * Math.cos(dist) +\n        Math.cos(lat1) * Math.sin(dist) * Math.cos(brng)\n    );\n\n    let lon2 =\n      lon1 +\n      Math.atan2(\n        Math.sin(brng) * Math.sin(dist) * Math.cos(lat1),\n        Math.cos(dist) - Math.sin(lat1) * Math.sin(lat2)\n      );\n\n    return {\n      lat: (lat2 * 180) / Math.PI,\n      lng: (lon2 * 180) / Math.PI,\n    };\n  };\n\n  /**\n    getIntersection\n\n    Calculate intersection point between two lines/routes in lat and lon.  They are not required to overlap to calulate\n\n   \n      @property {object} lineA\n        @property {number} lat\n        @property {number} lon\n\n      @property {object} lineB\n        @property {number} lat\n        @property {number} lon\n\n\n    @return {object}\n      @property {number} lat\n      @property {number} lon\n\n  */\n  const getIntersection = ({ lineA, lineB }) => {\n    let XAsum = lineA.start.lon - lineA.end.lon;\n    let XBsum = lineB.start.lon - lineB.end.lon;\n    let YAsum = lineA.start.lat - lineA.end.lat;\n    let YBsum = lineB.start.lat - lineB.end.lat;\n\n    let lineDenominator = XAsum * YBsum - YAsum * XBsum;\n    if (lineDenominator == 0.0) return false;\n\n    let a =\n      lineA.start.lon * lineA.end.lat - arrs.lineA.start.lat * lineA.end.lon;\n    let b = lineB.start.lon * lineB.end.lat - lineB.start.lat * lineB.end.lon;\n\n    let lat = (a * YBsum - b * YAsum) / lineDenominator;\n    let lon = (a * XBsum - b * XAsum) / lineDenominator;\n\n    return { lat, lon };\n  };\n\n  /**\n   * Returns (signed) distance from ‘this’ point to great circle defined by start-point and end-point.\n   *\n   * @param   {object} lineStart - Start point of great circle path.\n       @param {number} lat\n       @param {number} lon\n   * @param   {object} lineEnd - End point of great circle path.\n       @param {number} lat\n       @param {number} lon\n     @param   {object} currentPoint -current location\n         @param {number} lat\n         @param {number} lon\n   * @param   {bool} haversine - use haversine versus cosine calculation.  Cos is best for smalelr distances \n   * @returns {number} Distance to great circle (-ve if to left, +ve if to right of path).\n   *    *    \n   */\n  function crossTrackDistanceTo({\n    lineStart,\n    lineEnd,\n    currentPoint,\n    haversine = false,\n  }) {\n    let lineLength = haversine\n      ? this.getDistanceHaversine(lineStart, currentPoint, MEAN_RADIUS_IM_M) /\n        MEAN_RADIUS_IM_M\n      : this.getDistanceCos(lineStart, currentPoint, MEAN_RADIUS_IM_M) /\n        MEAN_RADIUS_IM_M;\n\n    let startToCurrent =\n      this.getBearingBetweenTwoPoints(lineStart, currentPoint) *\n      (Math.PI / 180);\n\n    let startLineBearing =\n      this.getBearingBetweenTwoPoints(lineStart, lineEnd) * (Math.PI / 180);\n\n    let XTE = Math.asin(\n      Math.sin(lineLength) * Math.sin(startToCurrent - startLineBearing)\n    );\n\n    return XTE * MEAN_RADIUS_IM_M;\n  }\n\n  /*------------------------------------------\n\n        AVERAGING and AGGREGATING FUNCTIONS\n\n    -------------------------------------------*/\n\n  /**\n      Get min, max, avg of a given property from array and filters out non numbers or bad data\n\n      @param {object} arrs\n        @property {array} array - Array of racedata objects to get min,max, avg from\n        @property {object} dataSource - propery of racedata object to use as basis for reducing array\n\n      @returns {object}\n        @property {number} max\n        @property {number} min\n        @property {number} avg\n\n    */\n  const getMinMaxAvgFromArray = (newArray) => {\n    //strips out bad data\n    let max = newArray.reduce(function (a, b) {\n      if (isNaN(a) || a === null || a === \"\") a = -Infinity;\n      if (isNaN(b) || b === null || b === \"\") b = -Infinity;\n      return Math.max(a, b);\n    }, -Infinity);\n\n    let min = newArray.reduce(function (a, b) {\n      if (isNaN(a) || a === null || a === \"\") a = Infinity;\n      if (isNaN(b) || b === null || b === \"\") b = Infinity;\n      return Math.min(a, b);\n    }, Infinity);\n\n    let avg =\n      newArray.reduce(function (previous, current) {\n        if (isNaN(current) || current === null || current === \"\")\n          return previous;\n        return previous + Number(current);\n      }, 0) / newArray.length;\n\n    return { min, max, avg };\n  };\n\n  /**\n   * Convert lat/lon to mercator projection points\n   */\n  const mercator = ({ latitude, longitude }) => {\n    const MAX = 85.0511287798;\n    const RADIANS = Math.PI / 180;\n    let point = {};\n\n    point.lon = RADIUS_IN_M * longitude * RADIANS;\n    point.lat = Math.max(Math.min(MAX, latitude), -MAX) * RADIANS;\n    point.lat = RADIUS_IN_M * Math.log(Math.tan(Math.PI / 4 + point.lat / 2));\n\n    return point;\n  };\n\n  /*-----------------------------------------------\n\n    TIME FUNCTIONS\n\n---------------------------------------------------*/\n\n  /**\n   * humanTime\n   *\n   * Produce human readable time from milliseconds.  Automatically hide/add mins secs days etc\n   *\n   */\n  const humanTime = (millisec) => {\n    let seconds = (millisec / 1000).toFixed(0);\n    let minutes = Math.floor(seconds / 60);\n    let hours = \"\";\n    if (minutes > 59) {\n      hours = Math.floor(minutes / 60);\n      hours = hours >= 10 ? hours : \"0\" + hours;\n      minutes = minutes - hours * 60;\n      minutes = minutes >= 10 ? minutes : \"0\" + minutes;\n    }\n\n    seconds = Math.floor(seconds % 60);\n    seconds = seconds >= 10 ? seconds : \"0\" + seconds;\n    if (hours != \"\") {\n      return hours + \":\" + minutes + \":\" + seconds;\n    }\n    return minutes + \":\" + seconds;\n  };\n\n  /*-----------------------------------------------------------------\n\n    LINE OR COURSE SMOOTHING ALGORYTHMS\n\n  ------------------------------------------------------------------*/\n  /**\n  GDouglasPeucker\n  Stack-based Douglas Peucker line simplification routine\n   returned is a reduced google.maps.LatLng array\n   After code by  Dr. Gary J. Robinson,\n   Environmental Systems Science Centre,\n   University of Reading, Reading, UK\n\n   @param {array} source Input coordinates\n   @param {number} kink in metres, kinks above this depth kept.  Kink depth is the height of the triangle abc where a-b and b-c are two consecutive line segments\n\n*/\n\n  function GDP_smoother(source, kink) {\n    let n_source, n_stack, n_dest, start, end, i, sig;\n    let dev_sqr, max_dev_sqr, band_sqr;\n    let x12, y12, d12, x13, y13, d13, x23, y23, d23;\n    let F = (Math.PI / 180.0) * 0.5;\n    let index = new Array(); /* aray of indexes of source points to include in the reduced line */\n    let sig_start = new Array(); /* indices of start & end of working section */\n    let sig_end = new Array();\n\n    /* check for simple cases */\n\n    if (source.length < 3) return source; /* one or two points */\n\n    /* more complex case. initialize stack */\n\n    n_source = source.length;\n    band_sqr =\n      (kink * 360.0) / (2.0 * Math.PI * 6378137.0); /* Now in degrees */\n    band_sqr *= band_sqr;\n    n_dest = 0;\n    sig_start[0] = 0;\n    sig_end[0] = n_source - 1;\n    n_stack = 1;\n\n    /* while the stack is not empty  ... */\n    while (n_stack > 0) {\n      /* ... pop the top-most entries off the stacks */\n\n      start = sig_start[n_stack - 1];\n      end = sig_end[n_stack - 1];\n      n_stack--;\n\n      if (end - start > 1) {\n        /* any intermediate points ? */\n\n        /* ... yes, so find most deviant intermediate point to\n                       either side of line joining start & end points */\n\n        x12 = source[end].lon - source[start].lon;\n        y12 = source[end].lat - source[start].lat;\n        if (Math.abs(x12) > 180.0) x12 = 360.0 - Math.abs(x12);\n        x12 *= Math.cos(\n          F * (source[end].lat + source[start].lat)\n        ); /* use avg lat to reduce lon */\n        d12 = x12 * x12 + y12 * y12;\n\n        for (i = start + 1, sig = start, max_dev_sqr = -1.0; i < end; i++) {\n          x13 = source[i].lon - source[start].lon;\n          y13 = source[i].lat - source[start].lat;\n          if (Math.abs(x13) > 180.0) x13 = 360.0 - Math.abs(x13);\n          x13 *= Math.cos(F * (source[i].lat + source[start].lat));\n          d13 = x13 * x13 + y13 * y13;\n\n          x23 = source[i].lon - source[end].lon;\n          y23 = source[i].lat - source[end].lat;\n          if (Math.abs(x23) > 180.0) x23 = 360.0 - Math.abs(x23);\n          x23 *= Math.cos(F * (source[i].lat + source[end].lat));\n          d23 = x23 * x23 + y23 * y23;\n\n          if (d13 >= d12 + d23) dev_sqr = d23;\n          else if (d23 >= d12 + d13) dev_sqr = d13;\n          else\n            dev_sqr = ((x13 * y12 - y13 * x12) * (x13 * y12 - y13 * x12)) / d12; // solve triangle\n\n          if (dev_sqr > max_dev_sqr) {\n            sig = i;\n            max_dev_sqr = dev_sqr;\n          }\n        }\n\n        if (max_dev_sqr < band_sqr) {\n          /* is there a sig. intermediate point ? */\n          /* ... no, so transfer current start point */\n          index[n_dest] = start;\n          n_dest++;\n        } else {\n          /* ... yes, so push two sub-sections on stack for further processing */\n          n_stack++;\n          sig_start[n_stack - 1] = sig;\n          sig_end[n_stack - 1] = end;\n          n_stack++;\n          sig_start[n_stack - 1] = start;\n          sig_end[n_stack - 1] = sig;\n        }\n      } else {\n        /* ... no intermediate points, so transfer current start point */\n        index[n_dest] = start;\n        n_dest++;\n      }\n    }\n\n    /* transfer last point */\n    index[n_dest] = n_source - 1;\n    n_dest++;\n\n    /* make return array */\n    let r = new Array();\n    for (let i = 0; i < n_dest; i++) r.push(source[index[i]]);\n\n    return r;\n  }\n\n  return {\n    getAvgOfBearings,\n    getBearingBetweenTwoPoints,\n    getBearingDiff,\n    addHeading,\n    invertHDG,\n    findMiddleAngle,\n    parseDMS,\n    getBoundsOfData,\n    getDistanceCos,\n    getDistanceHaversine,\n    getDistanceFromSpeedTime,\n    getPostionFromBearingAndDistance,\n    getIntersection,\n    crossTrackDistanceTo,\n    getMinMaxAvgFromArray,\n    mercator,\n    humanTime,\n    GDP_smoother,\n  };\n})();\n"],"sourceRoot":""}